package com.katesoft.gserver.domain;

import static com.google.common.base.Preconditions.checkNotNull;

import java.util.Set;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.dao.ConcurrencyFailureException;
import org.springframework.data.redis.core.BoundHashOperations;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.core.ValueOperations;
import org.springframework.data.redis.support.atomic.RedisAtomicLong;
import org.springframework.data.redis.support.collections.DefaultRedisList;

import com.google.common.base.Function;
import com.google.common.base.Optional;

public class RedisNamingConvention {
    private final Logger logger = LoggerFactory.getLogger( getClass() );
    private final StringRedisTemplate template;
    private final ValueOperations<String, String> opsForValue;
    private final String namespace;
    private final RedisAtomicLong idSequence;

    public RedisNamingConvention(StringRedisTemplate template, Class<?> persistentClass) {
        this.template = template;
        this.opsForValue = template.opsForValue();
        this.namespace = persistentClass.getSimpleName().toLowerCase();
        this.idSequence = new RedisAtomicLong( "seq_" + namespace, template.getConnectionFactory() );
    }
    public DefaultRedisList<String> newEntitiesList() {
        return new DefaultRedisList<String>( namespace + "s", template );
    }
    /**
     * save new entity with user callback function.
     * 
     * @param mapper - hash mapping function.
     * @return true if the entity does not exist at the moment of saving and being added to redis.
     */
    public boolean save(String pk, Function<BoundHashOperations<String, String, String>, BO> mapper) throws ConcurrencyFailureException {
        boolean added = false;
        String x = namespace + ":" + pk + ":uid";

        if ( opsForValue.get( x ) == null ) {
            long id = idSequence.incrementAndGet();
            String uid = String.valueOf( id );
            added = opsForValue.setIfAbsent( x, uid );

            if ( added ) {
                BoundHashOperations<String, String, String> ops = template.boundHashOps( namespace + ":" + uid );
                BO entity = mapper.apply( ops );
                entity.setAutoGeneratedId( id );

            }
            else {
                String exception = String.format( "detected concurrent modification exception for key = %s", x );
                logger.warn( exception );
                throw new ConcurrencyFailureException( exception );
            }
        }

        return added;
    }
    public Optional<BO> findByPrimaryKey(String pk, Function<BoundHashOperations<String, String, String>, BO> mapper) {
        checkNotNull( pk, "primary key not provided" );

        String x = namespace + ":" + pk + ":uid";
        String entityUid = opsForValue.get( x );
        BO entity = null;

        if ( entityUid != null ) {
            BoundHashOperations<String, String, String> ops = template.boundHashOps( namespace + ":" + entityUid );
            entity = mapper.apply( ops );
            entity.setAutoGeneratedId( Long.parseLong( entityUid ) );
        }

        return Optional.fromNullable( entity );
    }
    public void deleteByPrimaryKey(String pk) {
        String x = namespace + ":" + pk + ":uid";
        String entityUid = opsForValue.get( x );
        if ( entityUid != null ) {
            BoundHashOperations<String, String, String> ops = template.boundHashOps( namespace + ":" + entityUid );
            Set<String> keys = ops.keys();
            for ( String key : keys ) {
                ops.delete( key );
            }
            template.delete( x );
        }
    }
}
