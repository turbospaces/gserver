import "domain.proto";

package gserver;

option optimize_for = SPEED;
option java_package = "com.katesoft.gserver.commands";
option java_outer_classname = "Commands";
//
// attributes for each commands in protocol(transport level).
//
message MessageHeaders {
	required string correlationID = 1;
	required int64 sequenceNumber = 2;
	required int64 messageTimestamp = 3;
}
//
// Base command defines:
// 1) qualifier - fully/shortly qualified name of the command (i.e. 'login' or 'your.namespace.logincommand').
// 2) headers - transport level attributes.
// 3) protocolVersion - defines which protocol is being used on client side(server may want not be backwards compatible).
// 4) sessionId - if the user started game play, the game play will be always bound to session context.
// 5) debug - enable excessive command processing logging on server and command level.
//
message BaseCommand {
	extensions 100 to max;
	required string qualifier = 1;
	required MessageHeaders headers = 2;
	required string protocolVersion = 3;
	optional string sessionId = 4;
	optional bool debug = 5;
}

//
// server is not aware how to process inbound command (or either game specific command or platform command),
// possibly due to protocol version collision or any other difficulties.
//
message UnknownCommadException {
	extend BaseCommand {
		required UnknownCommadException cmd = 100;
	}
	required BaseCommand req = 1;
	optional string game = 2;
}
//
// if the game login fails, server sends this reply to client synchronously and closes connection.
// if the server in development mode, sends stack trace additionally.
//
message LoginCommnadException {
	extend BaseCommand {
		required LoginCommnadException cmd = 101;
	}
	required string msg = 1;
	optional string stacktrace = 2;
}
//
// login into game play with some token (for web applications it's may be cookie), but it's rather abstract.
// client needs to specify the target platform and optionally preferred game display language.
// server responds with LoginCommandReply message (generates session id).
// if the login command fails for any reason, server closes connection (and sends description to client before), so there is no special reply.
//
message LoginCommand {
	extend BaseCommand {
		required LoginCommand cmd = 102;
	}
	required string token = 1;
	required string clientPlatform = 3;
	optional string lang = 4;
}
//
// user can continue game play even after temporary server disconnection.
//
message ReloginCommand {
	extend BaseCommand {
		required ReloginCommand cmd = 103;
	}
	required string token = 1;
}
//
// gracefully close game play (without broken games creation, etc).
// this command expected by server at the end of game play.
// no response required to client.
//
message CloseGamePlayAndLogoutCommand {
	extend BaseCommand {
		required CloseGamePlayAndLogoutCommand cmd = 104;
	}
	required bool forceCloseConnection = 1 [default = true];
}
//
// reply to close play if the user doesn't force to close connection.
//
message CloseGamePlayAndLogoutReply {
	extend BaseCommand {
		required CloseGamePlayAndLogoutReply cmd = 105;
	}
}
//
// update common game play settings:
// 1) display user name
// 2) preferred display language
// 3) preferred pay-out currency
// 4) disable music (game music and background sounds)
//
message UpdatePlayerSettingsCommand {
	extend BaseCommand {
		required UpdatePlayerSettingsCommand cmd = 106;
	}
	required PlayerSettings settings = 1;
}
//
// open game play for specific game.
// the command itself is idempotent, you will be attached to existing player session instance if it's ongoing.
//
message OpenGamePlayCommand {
	extend BaseCommand {
		required OpenGamePlayCommand cmd = 110;
	}
	required string gameId = 1;
}
//
// reply to open game play command.
// contains bet limits for the game and coins layout and game display name.
//
message OpenGamePlayReply {
	extend BaseCommand {
		required OpenGamePlayReply cmd = 111;
	}
	required string sessionId = 1;
	required BetLimits betLimits = 2;
	required Coins coins = 3;
	required bool reattached = 4 [default = false];
}
